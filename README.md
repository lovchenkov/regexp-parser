# regexp-parser
 
## Описание
 
Программа получает на вход регулярное выражение `R` в обратной польской нотации(далее RPN) и букву `x` из алфавита `Σ = {a,b,c}`.
 
На выход программа пишет наибольшее натуральное `k`(или `INF`, если такого не существует), что в языке, задаваемом `R`, есть слово вида `x^kΣ*`.
 
## Алгоритм и реализация
 
Будем поддерживать стек `std::stack<Result> stack`, где `Result` - структура, имеющая следующие поля
 
```
struct Result {
  int max_prefix;
  int max_all;
  bool can_be_empty;
}; 
```
где 
 
`max_prefix` - ответ на задачу для текущего регулярного выражения `R'`, лишенного множетсва слов `{x^k}`(т.е. для слов из `R' \ {x^k}`).
 
`max_all` - ответ на задачу для текущего регулярного выражения `R'`, пересеченного с множеством слов `{x^k}`(т.е. для слов из `R' ∩ {x^k}`).
 
`can_be_empty` - флаг наличия пустого слова в текущем регулярном выражении.
 
Идем слева направо по регулярному выражению `R`. Есть три случая, в зависимости от того, чему равен очередной символ в `R`:
 
1. `y ∈ Σ`:  Кладем на стек `Result{y == x, y == x, false}`.
 
2. `*`: Берем верхний элемент `top` со стека и смотрим на его поля. Если `max_all != 0`, то у `R'` `max_all = INF`, иначе `0`. Аналогично обновляются остальные поля, эту логику можно найти в [`src/applier.h`](https://gitlab.akhcheck.ru/aleksei.ovchenkov/regexp-parser/-/blob/regexp-parser/src/applier.h?ref_type=heads#L10).
 
3. см. [`src/applier.h`](https://gitlab.akhcheck.ru/aleksei.ovchenkov/regexp-parser/-/blob/regexp-parser/src/applier.h?ref_type=heads#L10).


Таким образом, пройдя по всему `R`, на стеке останется одно число - ответ для всего регурного выражения. А именно, им будет `max(stack.top().max_prefix, stack.top().max_all)`.

Корректность данного алгоритма очевидна, в этом можно непосредственно убедиться, разобрав все случаи значений полей `Result` и операций, к ним применимых. Кажется, что этот README не расстроится от отсутствия данных выкладок.
 
## Асимптотика
 
Тут все просто - мы прошли строку `R` один раз и на каждой итерации сделали `O(1)` операций. Значит итоговая асимптотика `O(|R|)`.
 
## Запуск программы и тестов
 
* **Для начала, сделайте у себя локальную копию репозитория**
 
по SSH : `git clone ssh://git@gitlab.akhcheck.ru:2222/aleksei.ovchenkov/regexp-parser.git`
 
или HTTPS : `git clone https://gitlab.akhcheck.ru/aleksei.ovchenkov/regexp-parser.git`
 
 
 
* **Перейдите в папку `regexp-parser` и выполните команду**
 
` mkdir build && cd build && cmake .. && make`
 
* **Для запуска программы введите**
 
`./regexp-parser '<регулярное выражение R>' <буква x>`
 
Кавычки важны, иначе при наличии `*` в регулярном выражении команда может распарситься неправильно.
 
* **Для запуска тестов введите**
 
`./tests`
 
Так же есть возможность посчитать покрытие. Для этого после запуска тестов выполните
 
`make coverage && open coverage/index.html`

![Покрытие](https://ibb.co/SJMTYJN)

